# Process Seg Data

`art::TRIDFEventStore`で出力される`segdata`([Read RIDF files の節](../preparation/ridf.md)を参照してください。)から値を読み取って、それを TTree に格納するというシンプルなプロセッサを作りながら、同時に`segdata`について詳細に理解します。

## 状況設定

新しく、`segdata`から特定のチャンネルのデータを抜き出すようなプロセッサを作ってみましょう。

- `TChannelSelector`という名前のプロセッサにする
- CRIB 独自で開発したコードなので、`art::crib`という名前空間を用いる
- `segdata`をインプットとする
- 出力するブランチ名は、steering ファイルで指定し、`art::TSimpleData`を要素にもつ、`TClonesArray`の型で出力する。

> 現状 double や int などシンプルな型を出力するのに、[art::TOutputTreeProcessor](https://github.com/artemis-dev/artemis/blob/develop/sources/loop/TOutputTreeProcessor.cc) は対応していないようです。
> (`if 0`で始まる部分でそれを実装しようとした様子は見られますが、実際には実装できていないようです。)
> 従って、このプロセッサを使う場合、何らかのオブジェクトの形でブランチを作成する必要があります。
> 今回は、`fValue`のみを持つシンプルな`art::TSimpleData`型と、それを配列にするために、`TClonesArray`を用いることにします。

これを用いる steering ファイルの大まかな構造は以下の通りです。
parameter は都度追加していきます。

```yaml
Anchor:
  - &input ridf/@NAME@@NUM@.ridf
  - &output output/@NAME@/@NUM@/test@NAME@@NUM@.root

Processor:
  - name: timer
    type: art::TTimerProcessor

  - name: ridf
    type: art::TRIDFEventStore
    parameter:
      OutputTransparency: 1
      InputFiles:
        - *input

  - name: channel
    type: art::crib::TChannelSelector
    parameter:
      OutputTransparency: 0

  - name: outputtree
    type: art::TOutputTreeProcessor
    parameter:
      FileName:
        - *output
```

## ファイルの準備

まずは、[前節](./general_processors.md)に従って、`art::crib::TChannelSelector`の名前で、ヘッダファイルとソースファイルの枠組みを用意します。
このとき、`artcrib_linkdef.h`と`CMakeLists.txt`に作成するクラスを登録するのを忘れないでください。

中身は空のままで、一旦ビルドができるかどうかを試します。

```shell
artlogin <username>
cd build
cmake ..
make
make install
```

改めて、artemis をスタートできるかどうかを確かめ、エラーがでなければ準備はオッケーです。

```shell
acd
a
# -> エラーが出ない
```

## `segdata`の中身を確認する

### `segdata`を受け取る

`art::TRIDFEventStore`から出力される`segdata`を受け取り、どのような構造を持っているかを確かめましょう。

まずは必要な変数をヘッダファイルで宣言します。

```cpp
class TChannelSelector : public TProcessor {
  private:
    TString fSegmentedDataName;

    TSegmentedData *fSegmentedData; //!

    ClassDefOverride(TChannelSelector, 0);
};
```

`segdata`は`art::TSegmentedData`の型なので、受け取るためのポインタ変数を準備しておきます。

ソースファイルで`segdata`を受け取るためには以下のようにします。

```cpp
TChannelSelector::TChannelSelector() : fSegmentedData(nullptr) {
    RegisterInputCollection("SegmentedDataName", "name of the segmented data",
                            fSegmentedDataName, TString("segdata"));
}
```

まず、コンストラクタで`RegisterInputCollection()`を使って、`segdata`という名前をメンバ変数`fSegmentedDataName`に格納します。
実用上、`segdata`という名前は変えずに用いますが、steering ファイルで`SegmentedDataName`というパラメータを用意すると自由に変えることができます。
この場合は、`art::TRIDFEventStore`でもアウトプットするオブジェクトの名前を`segdata`から変える必要があるので、簡単のため、`segdata`のまま使用することをお勧めします。

名前が準備できたので、`Init()`メソッド(`add`コマンドを使用したとき)で、実際のオブジェクトのアドレスを受け取ります。

```cpp
#include <TSegmentedData.h>

void TChannelSelector::Init(TEventCollection *col) {
    // segdata process
    auto seg_ref = col->GetObjectRef(fSegmentedDataName);
    if (!seg_ref) {
        SetStateError(Form("No such input collection '%s'\n", fSegmentedDataName.Data()));
        return;
    }

    auto *seg_obj = static_cast<TObject *>(*seg_ref);
    if (!seg_obj->InheritsFrom("art::TSegmentedData")) {
        SetStateError(Form("'%s' is not of type art::TSegmentedData\n", fSegmentedDataName.Data()));
        return;
    }

    fSegmentedData = static_cast<TSegmentedData *>(seg_obj);
}
```

安全に処理を行うために、処理を多段階にしており、以下のような形で受け取っています。

- `TEventCollection`から`fSegmentedDataName`の名前のオブジェクトを受け取る
  - `col`は、処理全体で共通で用いられる`TEventCollection`のオブジェクトで、`GetObjectRef`で指定した名前のオブジェクトを受け取ることができる
  - 返り値の型は`void **`
- 受けとった参照が存在するかどうかを確認
- 受けとった参照から、`TObject *`にキャスト
- 今回想定しているのは`art::TSegmentedData *`型なので、その構造を持っているかどうかを確認する
- 最終的に、そのオブジェクトを`TSegmentedData *`にキャストし、それをメンバ変数の`fSegmentedData`に格納する

これで、受け取る準備ができました。Segment Data はイベント毎のデータなので、イベント毎に処理を行う`Process()`メソッド内で中身を確認します。

## `segdata`の内部構造

`segdata`から実際にデータにアクセスするまでの手順を見ていきます。

`TSegmentedData`は`TObjArray`を継承したオブジェクトです。
配列の要素は、一つの`[dev, fp, mod]`の組に対して一要素となっています。
例えば、以下のようなコードで各要素の情報を出力させてみます。
イベント毎に出力されてしまうので、大量にメッセージが表示されるので、`sus`コマンドで適宜イベントループを止めてください。

```cpp
void TChannelSelector::Process() {
    auto nSeg = fSegmentedData->GetEntriesFast();
    for (auto iSeg = 0; iSeg < nSeg; iSeg++) {
        auto *seg = fSegmentedData->UncheckedAt(iSeg);

        auto id = seg->GetUniqueID();
        // id is generated by `id = (dev << 20) + (fp << 14) + (mod << 8)`
        auto dev = (id >> 20) & 0xFFF;
        auto fp = (id >> 14) & 0x3F;
        auto mod = (id >> 8) & 0x3F;

        std::cout << "iSeg=" << iSeg << ", [dev=" << dev << ", fp=" << fp << ", mod=" << mod << "]\n";
    }
}
```

`[dev, fp, mod]`の三つの数字から、一つの**segid**を作成しているので、それを元の数字の組に戻す操作をしています。
適当な ridf ファイルを読み込ませると次のような出力になります。

```plaintext
iSeg=0, [dev=12, fp=1, mod=6]
iSeg=1, [dev=12, fp=1, mod=60]
iSeg=2, [dev=12, fp=2, mod=7]
iSeg=3, [dev=12, fp=2, mod=63]
iSeg=4, [dev=12, fp=2, mod=60]
iSeg=5, [dev=12, fp=0, mod=7]
iSeg=6, [dev=12, fp=0, mod=60]
```

ここから、`segid`は 7 個の要素を持っていることが分かりました。
全てを表示させるのは冗長なので、一つの例として、`[dev=12, fp=0, mod=7]`のデータを取り出すことにします。
これは V1190 でとったデータです。
先ほどの`Process()`で書いた内容を削除し、次のように書き換えます。

```cpp
#include <TRawDataObject.h>

void TChannelSelector::Process() {
    auto *seg_array = fSegmentedData->FindSegment(12, 0, 7);
    if (!seg_array) {
        Warning("Process", "No segment having segid = [dev=12, fp=0, mod=7]");
        return;
    }

    auto nData = seg_array->GetEntriesFast();
    for (auto iData = 0; iData < nData; iData++) {
        auto *data = (TRawDataObject *)seg_array->UncheckedAt(iData);
        auto geo = data->GetGeo();
        auto ch = data->GetCh();
        auto val = data->GetValue();
        std::cout << "iData=" << iData << ", [geo=" << geo << ", ch=" << ch << ", val=" << val << "]\n";
    }
}
```

以下のような処理を行っています。

- `FindSegment(dev, fp, mod)`メソッドで、その特定の**segid**の要素だけを受け取ることができます
- 返り値は`TObjArray *`で、その**segid**が持つデータが全て、配列の形として格納されています。
- 各要素について、`TRawDataObject *`の形にキャストしてデータを受け取っています。

ここで、デコードされたデータは次のようなクラスの中に格納されています。
CRIB で現在用いられている、V7XX (V785, V775)、MXDC32 (MADC32)、V1190 についてまとめると以下のようになります。
スケーラについてはここでは述べません。

| Module            | Class                     | Description                                                                                                                                  |
| ----------------- | ------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| V7XX (V775, V785) | `art::TRawTiming`         | `art::TRawDataObject` -> `art::TRawDataSimple` -> `art::TRawTiming` と継承されている。ADC で取ったデータも名前は Timing となっている         |
| MXDC32 (MADC32)   | `art::TRawTiming`         | 上と同様。                                                                                                                                   |
| V1190             | `art::TRawTimingWithEdge` | `art::TRawTiming` -> `art::TRawTimingWithEdge`と継承されている。leading edge と trailing egde の両方のタイミングをとる場合にも対応している。 |

- 全てのデコードされたオブジェクトは、`art::TRawDataObject`を継承した構造になっているので、このデータ型にキャストしてデータを取り出します。
  - 最終的なクラスは違っても、仮想関数になっているので、どのデータでも同じ処理で値を取り出すことができます。
- `[geo, ch]`の値と、そのデータを`val`という変数で取り出し、それをコンソールに表示させています。

具体的な出力例は以下のようになります。

```plaintext
iData=0, [geo=0, ch=2, val=9082]
iData=1, [geo=0, ch=2, val=9554]
iData=2, [geo=0, ch=0, val=25330]
iData=3, [geo=0, ch=0, val=26274]
iData=4, [geo=1, ch=2, val=9210]
iData=5, [geo=1, ch=2, val=9674]
iData=6, [geo=1, ch=0, val=25449]
iData=7, [geo=1, ch=0, val=26393]
iData=8, [geo=1, ch=70, val=30483]
iData=9, [geo=1, ch=74, val=8458]
iData=10, [geo=1, ch=85, val=8651]
iData=11, [geo=1, ch=74, val=9163]
iData=12, [geo=1, ch=85, val=9172]
iData=13, [geo=1, ch=85, val=30502]
iData=14, [geo=1, ch=86, val=30401]
iData=15, [geo=1, ch=106, val=8611]
iData=16, [geo=1, ch=117, val=8466]
iData=17, [geo=1, ch=106, val=9298]
iData=18, [geo=1, ch=117, val=9159]
iData=19, [geo=1, ch=117, val=30482]
iData=20, [geo=1, ch=118, val=30525]
```

このようにして、`art::TRIDFEventStore`でデコードされたデータにアクセスすることができます。

## `TChannelSelector`の実装

目標であった、`segdata`から特定のチャンネルだけを取り出す処理を実装していきます。

### パラメータの準備

まずは、steering ファイルから、どのチャンネルを取り出すかを指定することができるようにします。
つまり、steering ファイルから変数を読み込ませられるようにします。
名前を`SegID`として steering ファイルを次のように準備します。

```yaml
- name: channel
  type: art::crib::TChannelSelector
  parameter:
    SegID: [12, 0, 7, 0, 2]
```

`SegID`として、`[dev, fp, mod, geo, ch]`の形で取り出したいチャンネルを指定できるようにします。

受け取った値を、クラスのメンバ変数として格納できるように、ヘッダファイルに変数を準備します。

```cpp
class TChannelSelector : public TProcessor {
  private:
    IntVec_t fSegID; //!
}
```

次に、ソースファイルのコンストラクタの実装部分で変数を steering ファイルから受け取れるようにします。

```cpp
TChannelSelector::TChannelSelector() : fSegmentedData(nullptr) {
    IntVec_t init_i_vec;
    RegisterProcessorParameter("SegID", "segment ID, [dev, fp, mod, geo, ch]",
                               fSegID, init_i_vec);
}
```

`IntVec_t init_i_vec;`を空の`std::vector`として、デフォルト値に設定しておきます。
次に、`Init()`メソッドで、正しく読み込まれているかどうかを確認する処理を加えます。

```cpp
void TChannelSelector::Init(TEventCollection *col) {
    // segid process
    if (fSegID.size() != 5) {
        SetStateError("parameter: SegID size is not 5, input [dev, fp, mod, geo, ch]\n");
        return;
    }
    Info("Init", "Process [dev=%d, fp=%d, mod=%d, geo=%d, ch=%d]", fSegID[0], fSegID[1], fSegID[2], fSegID[3], fSegID[4]);
}
```

サイズが 5 でなかった場合は、エラーを出力して終了させる処理を加え、またログとして、どのようなパラメータが入力されたかを出力するようにしています。

### 出力ブランチの準備

次に ROOT ファイルに保存するブランチを準備します。
前述の通り、現状は`int`型などシンプルなブランチを用いることはできず、`TObject`を継承したオブジェクトのみをブランチにすることができます。

今回は、一つのイベントに複数のデータが入っていても対応できるように`TClonesArray`を用いたいと思います。
artemis では、ほとんどの処理でこの`TClonesArray`が用いられています。

まず、ヘッダファイルにブランチの名前を格納する変数と、そのオブジェクトの変数を定義します。

```cpp
class TChannelSelector : public TProcessor {
  private:
    TString fOutputColName;
    TClonesArray *fOutData; //!
}
```

ソースファイルのコンストラクタの実装で、steering ファイルからブランチの名前を受け取る処理を加えます。

```cpp
TChannelSelector::TChannelSelector() : fSegmentedData(nullptr), fOutData(nullptr) {
    RegisterOutputCollection("OutputCollection", "name of the output branch",
                             fOutputColName, TString("output"));
}
```

この時、`RegisterOutputCollection()`を用います。
このようにすることで、steering ファイルから、ブランチの名前を指定できるようになります。

```yaml
- name: channel
  type: art::crib::TChannelSelector
  parameter:
    OutputCollection: channel
    SegID: [12, 0, 6, 0, 2]
```

最後に、`Init()`メソッドで、この新たなブランチを`TEventCollection`のオブジェクトに追加します。

```cpp
#include <TSimpleData.h>

void TChannelSelector::Init(TEventCollection *col) {
    fOutData = new TClonesArray("art::TSimpleData");
    fOutData->SetName(fOutputColName);
    col->Add(fOutputColName, fOutData, fOutputIsTransparent);
    Info("Init", "%s -> %s", fSegmentedDataName.Data(), fOutputColName.Data());
}
```

- `art::TSimpleData`の要素の`TClonesArray`を使っています。
- `segdata`から指定した名前のブランチが作成されることをログに出力するようにしています。

### 処理の実装

`Process()`メソッドでチャンネルを選択し、それをブランチにつめる具体的な処理を実装していきます。

まず、イベント毎に値をクリアしたいのではじめに以下を記述します。

```cpp
void TChannelSelector::Process() {
    fOutData->Clear("C");
}
```

この処理を書かないと、前のデータが残ってしまい、正しいデータをブランチに格納することができません。
まずクリア処理をすることを忘れないでください。

その他の処理内容は以下の通りです。

```cpp
void TChannelSelector::Process() {
    auto *seg_array = fSegmentedData->FindSegment(fSegID[0], fSegID[1], fSegID[2]);
    if (!seg_array) {
        Warning("Process", "No segment having segid = [dev=%d, fp=%d, mod=%d]", fSegID[0], fSegID[1], fSegID[2]);
        return;
    }

    auto nData = seg_array->GetEntriesFast();
    auto counter = 0;
    for (auto iData = 0; iData < nData; iData++) {
        auto *data = (TRawDataObject *)seg_array->UncheckedAt(iData);
        auto geo = data->GetGeo();
        auto ch = data->GetCh();
        if (geo == fSegID[3] && ch == fSegID[4]) {
            auto *outData = static_cast<art::TSimpleData *>(fOutData->ConstructedAt(counter));
            counter++;
            outData->SetValue(data->GetValue());
        }
    }
}
```

**segid**は、steering ファイルから受け取ったものを使っているということ以外は、以前とほぼ同様のコードです。

`for`の中の処理で、指定した`[geo, ch]`と一致した場合に、`fOutData`に値を設定するようにしています。
`TClonesArray`に要素を追加するときには`ConstructedAt(index)`を用います。
ここでは`counter`変数を利用して、後に要素を追加していくような処理を行っています。

`art::TSimpleData`の`fValue`に値を設定するには、`SetValue(value)`というメソッドを使います。
条件を満たすデータのみ、`data->GetValue()`で値を受け取って、それを`art::TSimpleData`の`fValue`にセットしています。

これで完成です。
作成したプロセッサを使って、`tree`の中を見てみると次のようになっています。

```shell
artemis [] add steering/hoge.yaml NAME=xxxx NUM=xxxx
artemis [] res
artemis [] sus
artemis [] fcd 0
artemis [] tree->Scan("channel.fValue")
```

```plaintext
***********************************
*    Row   * Instance * channel.f *
***********************************
*        0 *        0 *      9314 *
*        0 *        1 *      9818 *
*        1 *        0 *           *
*        2 *        0 *      3842 *
*        2 *        1 *      4550 *
*        3 *        0 *           *
*        4 *        0 *      8518 *
*        4 *        1 *      9107 *
*        5 *        0 *           *
*        6 *        0 *           *
*        7 *        0 *           *
*        8 *        0 *           *
*        9 *        0 *           *
*       10 *        0 *           *
*       11 *        0 *      8375 *
*       11 *        1 *      9035 *
*       12 *        0 *           *
*       13 *        0 *      2276 *
*       13 *        1 *      2735 *
*       14 *        0 *     24560 *
*       14 *        1 *     25360 *
*       15 *        0 *           *
*       16 *        0 *           *
*       17 *        0 *           *
*       18 *        0 *           *
```

この例では、V1190 を**Both Edge**モードで取得したデータなので、各データに対して二つの値があることが確認できます。
