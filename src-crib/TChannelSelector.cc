/**
 * @file    TChannelSelector.cc
 * @brief   extract one channel data
 * @author  Kodai Okawa <okawa@cns.s.u-tokyo.ac.jp>
 * @date    2024-12-18 15:41:32
 * @note    last modified: 2024-12-19 23:15:50
 * @details
 */

#include "TChannelSelector.h"

#include <TRawDataObject.h>
#include <TSegmentedData.h>

ClassImp(art::crib::TChannelSelector);

namespace art::crib {
TChannelSelector::TChannelSelector() : fInData(nullptr), fSegmentedData(nullptr), fCategorizedData(nullptr) {
    RegisterInputCollection("SegmentedDataName", "name of the segmented data",
                            fSegmentedDataName, TString("segdata"));

    IntVec_t init_i_vec;
    RegisterProcessorParameter("Debug", "debug mode (bool)",
                               fDebug, false);
    RegisterProcessorParameter("SegID", "segment ID, [dev, fp, mod, geo, ch]",
                               fSegID, init_i_vec);
}

TChannelSelector::~TChannelSelector() {
    fSegmentedData = nullptr;
}

void TChannelSelector::Init(TEventCollection *col) {
    // segdata process
    auto seg_ref = col->GetObjectRef(fSegmentedDataName);
    if (!seg_ref) {
        SetStateError(Form("No such input collection '%s'\n", fSegmentedDataName.Data()));
        return;
    }

    auto *seg_obj = static_cast<TObject *>(*seg_ref);
    if (!seg_obj->InheritsFrom("art::TSegmentedData")) {
        SetStateError(Form("'%s' is not of type art::TSegmentedData\n", fSegmentedDataName.Data()));
        return;
    }

    fSegmentedData = static_cast<TSegmentedData *>(seg_obj);

    // segid process
    if (fSegID.size() != 5) {
        SetStateError("parameter: SegID size is not 5, input [dev, fp, mod, geo, ch]\n");
        return;
    }

    Info("Init", "Process [dev=%d, fp=%d, mod=%d, geo=%d, ch=%d]", fSegID[0], fSegID[1], fSegID[2], fSegID[3], fSegID[4]);
}

void TChannelSelector::Process() {
    if (fDebug) {
        auto nSeg = fSegmentedData->GetEntriesFast();
        for (auto iSeg = 0; iSeg < nSeg; iSeg++) {
            auto *seg = fSegmentedData->UncheckedAt(iSeg);

            auto id = seg->GetUniqueID();
            // id is generated by `id = (dev << 20) + (fp << 14) + (mod << 8)`
            auto dev = (id >> 20) & 0xFFF;
            auto fp = (id >> 14) & 0x3F;
            auto mod = (id >> 8) & 0x3F;

            std::cout << "iSeg=" << iSeg << ", [dev=" << dev << ", fp=" << fp << ", mod=" << mod << "]\n";
        }
    }

    auto *seg_array = fSegmentedData->FindSegment(fSegID[0], fSegID[1], fSegID[2]);
    if (!seg_array) {
        Warning("Process", "No segment having segid = [dev=%d, fp=%d, mod=%d]", fSegID[0], fSegID[1], fSegID[2]);
    }

    auto nData = seg_array->GetEntriesFast();
    auto counter = 0;
    for (Int_t iData = 0; iData < nData; iData++) {
        TRawDataObject *data = (TRawDataObject *)seg_array->UncheckedAt(iData);
        Int_t geo = data->GetGeo();
        Int_t ch = data->GetCh();
        Int_t nVal = data->GetNumValues();
        // counter++;
        // std::cout << counter << " " << geo << " " << ch << " " << nVal << std::endl;
    }
    std::cout << std::endl;
}

} // namespace art::crib
